# -*- coding: utf-8 -*-
"""Séries Temporais

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LJVF2PGIs0cVT7bgTlvUn5WAh6RbSw4o
"""

# Commented out IPython magic to ensure Python compatibility.
#Importando as bibliotecas
import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_style()

# %matplotlib inline

#URL do dataset
dataset_path = "https://raw.githubusercontent.com/carlosfab/escola-data-science/master/datasets/electricity_consumption/Electric_Production.csv"

#Lendo o URL
df = pd.read_csv(dataset_path)
df.head()

# [ANTES] converter tipo da coluna DATE em datetime
print("[ANTES]")
display(df.DATE.head())

# [DEPOIS] converter tipo da coluna DATE em datetime
print("[DEPOIS]")
display(pd.to_datetime(df.DATE, format="%m-%d-%Y").head())

# converter DATE para datetime e associar ao index do dataframe
df.index = pd.to_datetime(df.DATE, format="%m-%d-%Y")

# eliminar a coluna DATE
df.drop("DATE", axis=1, inplace=True)

# ver as primeiras 5 entradas
df.head()

#Plotando gráfico do consumo de eletricidade
plt.plot(df.index, df.Value)

#Usamos o df.index, pois as datas foram convertidas para índice

#Decompondo o gráfico em tendências e sazonalidades
#Salvando a decomposição em uma variável
result = seasonal_decompose(df, model = "multiplicative")

#plotando a decomposição
#result.plot();

fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(15,8))
result.observed.plot(ax=ax1)
result.trend.plot(ax=ax2)
result.seasonal.plot(ax=ax3)
result.resid.plot(ax=ax4)
plt.tight_layout()

#resíduo é o que a função não conseguiu extrair, pode ser chamada de erro ou resíduo

#URL do dataset
data_ferroviaria = "https://github.com/carlosfab/escola-data-science/raw/master/datasets/companhia_ferroviaria/trem.csv"

#Lendo o arquivo
df_trem = pd.read_csv(data_ferroviaria)
print(df_trem.head())

#Convertendo a coluna Date
df_trem.Datetime = pd.to_datetime(df_trem.Datetime, format="%d-%m-%Y %H:%M")
print(df_trem.head())
print(type(df_trem))

fig, ax = plt.subplots(figsize=(15,6))
df_trem.plot(x="Datetime", y='Count', ax=ax);
#o ; serve para inibir o retorno (a mensagem acima do gráfico)

'''Hipóteses:
Julho tem menos deslocamento de trem, pois é férias escolares
Pessoas viajam mais durante a semana'''

#criando features para cada período
#dt.year cria uma coluna nova só com o ano
#df_trem['Year] pois tem que informar o nome da coluna que será criada

df_trem['Year']=df_trem.Datetime.dt.year
df_trem['Month']=df_trem.Datetime.dt.month
df_trem['Day']=df_trem.Datetime.dt.day
df_trem['Hour'] = df_trem.Datetime.dt.hour
df_trem['Day_of_week']=df_trem.Datetime.dt.dayofweek

#0 = segunda - 6 domingo

df_trem.head()

#Converter os finais de semana em 1
#Todos os dias serão zero
df_trem['weekend'] = 0

#somente os finais de semana serão 1
#Se o dia da semana for sábado (5) ou domingo (6) a coluna de final de semana (weekend) recebe 1
df_trem.loc[(df_trem.Day_of_week == 5) | (df_trem.Day_of_week == 6), 'weekend'] = 1

df_trem.head()

#Verificar os valores final de semana com os dias da semana
df_trem.weekend.value_counts()

#Plotando um gráfico de barras
'''Groupby = agrupa por weekend e a variável é a quantidade é a contagem (0 ou 1)
mean faz a média desse valor e plota em forma de barra'''

df_trem.groupby('weekend').Count.mean().plot.bar();

#Há períodos de picos devido a idas e vindas
df_trem.groupby('Hour').Count.mean().plot.bar();

#Visualizando por mês
df_trem.groupby('Month').Count.mean().plot.bar();

sc